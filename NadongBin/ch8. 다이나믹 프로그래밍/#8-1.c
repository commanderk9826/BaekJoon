/*
다이나믹 프로그래밍(Dynamic Programming) = 동적 계획법
1. 큰 문제를 작은문제로 나눌 수 있다.
2. 작은문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
-> 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법
---------------------------------------------------
1. Top-down(메모이제이션) = '하향식'
: 큰 문제를 해결하기 위해 작은 문제를 호출
-> 메모이제이션은 탑 다운 방식에 국한되어 사용됨.

2. Bottom-up = '상향식'
: 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출
-> 보텀업 방식에 사용되는 결과 저장용 리스트 : DP 테이블

3. Memoization(= Cashing : 값을 저장하는 방법)
: 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
---------------------------------------------------
ex) 피보나치 수열 by 메모이제이션 기법
한번 구한 정보를 리스트에 저장하여 메모이제이션을 구현한다. 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는
이미 구한 정답을 그대로 리스트에서 가져오면 된다.

다이나믹 프로그래밍 VS 분할 정복(퀵 정렬)  : 문제들이 서로 영향을 미치고 있음.

//피보나치 수열
#include <stdio.h>
int fibo(int x){
    if(x==1||x==2) return 1;

    return fibo(x-1)+fibo(x-2);
}

int main(){
    printf("%d\n", fibo(4));
    return 0;
}
    
*/

// 피보나치 수열 by 메모이제이션 기법
#include <stdio.h>

#define MAX 100

// 메모이제이션을 위한 배열 초기화(0으로 초기화)
// 배열을 사용해 중복 계산을 방지
int d[MAX]={0};

// 피보나치 수열 함수(재귀+메모이제이션)
int fibo(int x){
    // 호출된 함수 출력
    printf("f(%d) ", x);
    if(x==1||x==2) return 1;

    // 이미 계산된 값이면 그대로 반환
    if(d[x] !=0) return d[x];

    // 점화식에 따라 피보나치 수 계산 후 저장
    // 재귀 호출을 활용한 다이나믹 프로그래밍(탑 다운 방식)
    d[x]= fibo(x-1)+fibo(x-2);
    return d[x];
}

int main(){
    fibo(6);
    printf("\n%d\n", fibo(6));
    return 0;
}